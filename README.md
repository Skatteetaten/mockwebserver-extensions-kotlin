# MockMvc extensions Kotlin

This project was created to have one source, the unit test, for documentation and contracts.
It simplifies the setup of `MockMvc` tests that generates [restdocs](https://spring.io/projects/spring-restdocs)
and wiremock stubs using [Spring Cloud Contract](https://spring.io/projects/spring-cloud-contract).

For examples look at the [unit tests](https://github.com/Skatteetaten/mockmvc-extensions-kotlin/blob/master/src/test/kotlin/no/skatteetaten/aurora/mockmvc/extensions/ControllerIntegrationTest.kt).

## Usage

**GET request**
```
mockMvc.get(
  path = Path("/test/{id}", "123"),
  headers = HttpHeaders().authorization("test"),
  docsIdentifier = "my-docs"
) {
   statusIsOk().responseJsonPath("$.value").equalsValue("test")
}
```

**POST request with `body`**
```
mockMvc.post(
  path = Path("/test"),
  body = "test123"
) {
    statusIsOk().responseJsonPath("$.key").equalsValue("test123")
}
```


| Name | Description | WireMock usage |
|------|-------------|----------------|
| headers         | The HTTP headers used in the request                                | Check that the header is present, does not check the value |
| body            | The request body, used for POST, PUT, PATCH and DELETE.             | Not used in the wiremock stub |
| docsIdentifier  | The name of the snippet generated by restdocs.                      | Not used in stubs  |
| path            | The request path. For example: `Path("/test")` or `Path("/test/{id}", "123")` | `Path` without placeholders (vars) will trigger a full comparison in the WireMock stub, the priority is set to 1.<br><br>`Path` with placeholders (vars) replaces the placeholders with a regex, for example `Path("/test/{id}", "123")`, the WireMock stubs generated will contain a wildcard for the placeholder, `/test/[\w-]+`. This means that both the path `/test/123` and `/test/abc` will match. Path with placeholder has priority 2.<br><br>If two paths overlap, the one with the lowest priority number wins.|

---

There are also convenience methods for asserting with JsonPath.  
* *Equals value:* `statusIsOk().responseJsonPath("$.value").equalsValue("test")`
* *Equals object:* `statusIsOk().responseJsonPath("$").equalsObject(TestObject())`
* *Contains:*  `statusIsOk().responseJsonPath("$").contains("test"))`

And to assert on response headers
* *equals:* `statusIsOk().responseHeader(CONTENT_TYPE).equals(APPLICATION_JSON_UTF8_VALUE)`
* *startsWith:* `statusIsOk().responseHeader(CONTENT_TYPE).startsWith(APPLICATION_JSON_VALUE)`

## Custom Dispatcher DSL
An alternate way of mocking is by using our httpMockServer dsl that uses a custom dispatcher.
```
val server:MockWebServer = httpMockServer(8282) {
  rule({ path?.endsWith("sith")}) {
    MockResponse().setBody("Darth Vader")
  }
  rule {
    MockResponse().setBody("Yoda")
  }
}
```

This will create a MockWebServer that will evaluate all calls against the rules in the block in order. 
The optional parameter to the rule is guard, you can also return null inside a rule to ignore that rule

See the file httpMock.kt for more details. 

There is a convenience method `HttpMock.clearAllHttpMocks()` for clearing up all mocks created with the DSL.

It is also possible to initialize a `MockWebServer` that is not started, where you can add rules after it is created.
If you need to stop the server and clear the HttpMocks, for instance to avoid it bleeding into other tests,
use the `executeRulesAndClearMocks` function or manually call `HttpMock.clearAllHttpMocks()`.

```
val httpMock = initHttpMockServer {
    rule({ path?.endsWith("sith")}) {
        MockResponse().setBody("Darth Vader")
    }
}
httpMock.rule({ path?.endsWith("jedi") }) {
    MockResponse().setBody("Yoda")
}

httpMock.executeRules {
    val response1 = RestTemplate().getForEntity<String>("${it.url}/jedi")
    val response2 = RestTemplate().getForEntity<String>("${it.url}/sith")
    ...
}
```

## Rest docs

To generate rest docs add `@AutoConfigureRestDocs` to your unit test class.
By default the snippet name will be generated based on the HTTP verb and path, for example `GET /test/{id}` will generate `get-test-id`.

You can also specify the snippet name directly by including `docsIdentier`:
```
mockMvc.get(path = Path("/test"), docsIdentifier = "my-docs") { ... }
```

This will by default generate the restdocs snippets in `<target/build>/generated-snippets/<docsIdentifier>/*.adoc`


## Custom ObjectMapper

In certain test cases it is useful to send in a custom `ObjectMapper` instance. This can either be done on individual functions:
```
server.execute(201 to TestObject("test"), objectMapper = jacksonObjectMapper()) { ... }
```

Or by setting the `ObjectMapper` before the actual unit tests run: 
```
init {
    TestObjectMapperConfigurer.objectMapper = customObjectMapper()
}

@AfterAll
fun tearDown() {
    TestObjectMapperConfigurer.reset()
}
```


## WireMock

For information on how to setup the contract consumer see the [Spring Cloud Contract documentation](https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_client_side)

### Build script

The build script must package the stub-jar file,
for more details take a look at [this sample from Spring Cloud Contract](https://github.com/spring-cloud-samples/spring-cloud-contract-samples/blob/master/producer_with_restdocs/build.gradle#L83)


